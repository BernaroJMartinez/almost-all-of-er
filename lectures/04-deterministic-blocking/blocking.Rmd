
---
title: "Module 4: Deterministic Blocking"
author: "Rebecca C. Steorts"
institute: joint with Olivier Binette
output: 
     beamer_presentation:
      includes: 
          in_header: custom2.tex
font-size: 8px
---

Reading
===

- Binette and Steorts (2020)
- Steorts, Ventura, Sadinle, Fienberg (2014)
- Murray (2016)

Agenda
===

- Data Cleaning Pipeline
- Blocking
- Traditional Blocking
- Probabilistic Blocking

Load R packages and data
===

```{r, echo=TRUE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      fig.width=4, 
                      fig.height=3, 
                      fig.align="center")
library(RecordLinkage)
library(blink)
library(italy)
library(tidyverse)
library(assert)
data(italy08)
data(italy10)
data(RLdata500)
```

Data Cleaning Pipeline
===

\begin{figure}
  \begin{center}
    \includegraphics[width=\textwidth]{finalFigures/pipeline}
    \caption{Data cleaning pipeline.}
    \end{center}
\end{figure}

Blocking
===

\begin{figure}
  \begin{center}
    \includegraphics[width=\textwidth]{finalFigures/block.png}
    \caption{Left: All to all record comparison. Right: Example of resulting blocking partitions. }
    \end{center}
\end{figure}


Blocking
===

- Blocking partitions similar records into partitions/blocks.

- ER is only performed within each blocks. 

Traditional Blocking
===

- A deterministic (fixed) partition is formed based upon the data. 
- A partition is created by treating certain fields that are thought to be nearly error-free as fixed.
- Benefits:  simple, easy to understand, and fast to implement. 
- Downsides: the blocks are treated as error free, which is not usually accurate and can lead to errors in the ER task that cannot be accounted for. 

Example: Blocking on date of birth year. 

Probabilistic Blocking 
===

- A probability model is used to cluster the data into blocks/partitions. 

Example: Fellegi-Sunter (1969), or Locality Sensitive Hashing  

Under both blocking approaches, record pairs that do not meet the blocking criteria are automatically classified as non-matches.

# Example: Traditional blocking



\begin{figure}
  \begin{center}
    \includegraphics[width=0.45\textwidth]{FinalFigures/noblocking_plot.pdf}
    \includegraphics[width=0.45\textwidth]{FinalFigures/blocking_plot.pdf}
    \caption{All-to-all record comparisons (left) versus partitioning records into blocks by lastname initial and comparing records only within each partition (right).}
    \end{center}
\end{figure}

# Example: RLdata500

```{r, eval=TRUE, message=FALSE, warning=FALSE}
head(RLdata500)
```

# RLdata500 (Continued)

```{r, eval=TRUE, message=FALSE, warning=FALSE}
# Total number of all to all record comparisons
choose(500,2)
```

# RLdata500 (Continued)

```{r, eval=TRUE, message=FALSE, warning=FALSE}
# Block by last name initial  
last_init <- substr(RLdata500[,"lname_c1"], 1, 1)
head(last_init)

# Total number of blocks
length(unique(last_init))
```

# RLdata500 (Continued)

```{r, eval=TRUE, message=FALSE, warning=FALSE}
# Total number of records per block
recordsPerBlock <- table(last_init)
head(recordsPerBlock)
```

# RLdata500 (Continued)

```{r, eval=TRUE, message=FALSE, warning=FALSE, fig.width=5}
# Block sizes can vary 
plot(recordsPerBlock, 
     cex.axis=0.6, xlab="", ylab="")
```

# RLdata500 (Continued)

```{r, eval=TRUE, message=FALSE, warning=FALSE}
# Total number of records pairs per block
choose(recordsPerBlock, 2)

# Reduction on comparison space
sum(choose(recordsPerBlock, 2))
```

# RLdata500 (Continued)

What is the overall dimension reduction form the original space to the reduced space induced by blocking? 

Recall the original space of comparisons was 
```{r, eval=TRUE, message=FALSE, warning=FALSE}
choose(500, 2)
```

We have reduced the number of comparisons to 
```{r, eval=TRUE, message=FALSE, warning=FALSE}
sum(choose(recordsPerBlock, 2))
```

# How do we calculate the reducation ratio?

The reduction ratio is
$$
  \text{RR} = \text{\% comparisons eliminated by blocking.}
$$

```{r}
(choose(500, 2) - sum(choose(recordsPerBlock, 2))) / 
choose(500, 2)
```

# How do we calculate the reducation ratio (via a function)?

```{r}
reduction.ratio <- function(block.labels) {
  n_all_comp = choose(length(block.labels), 2)
  n_block_comp = sum(choose(table(block.labels), 2))

  (n_all_comp - n_block_comp) / n_all_comp
}

reduction.ratio(last_init)
```

# Pairwise Precision

```{r}
labels = unique(last_init)

# Number of matching pairs among blocks
n_matches = sapply(labels, function(label) {
  # Records in a given blocks
  records = which(last_init == label)
  # Number of matches in that block
  sum(duplicated(identity.RLdata500[records]))
})

# Total number of pairs
n_pairs = sum(choose(table(last_init), 2))

sum(n_matches) / n_pairs
```

# Pairwise Precision

```{r}
precision <- function(block.labels, IDs) {
  labels = unique(block.labels)

  # Number of matching pairs among blocks
  n_matches = sapply(labels, function(label) {
    records = which(block.labels == label)
    sum(duplicated(IDs[records]))
  })
  
  # Total number of pairs
  n_pairs = sum(choose(table(block.labels), 2))

  sum(n_matches) / n_pairs
}

precision(last_init, identity.RLdata500)
```

# Pairwise Recall

```{r}
recall <- function(block.labels, IDs) {
  precision(IDs, block.labels)
}
```


# Italian Survey on Household and Wealth (SHIW)

We will now explore a case study to the SHIW 

# SHIW

- The Italian Survey on Household and Wealth (SHIW) is a sample survey 383 households
conducted by the Bank of Italy every two years (2008 and 2010).
- The data set is anonymized to remove first and last name (and other sensitive information). 

# SHIW

The following attribute information is available: 

\begin{itemize}
\item PARENT (parental status)
\item GENDER
\item ANASC (year of birth)
\item NASCREG (working status)
\item CIT (employment status)
\item ACOM4C (branch of activity)
\item STUDIO (town size)
\item Q (quality of life status)
\item QUAL (whether or not Italian national)
\item SETT (highest educational level obtained)
\item IREG (region of italy)
\end{itemize}

# Explore Data

\tiny
```{r}
head(italy08) # first year of SHIW
```

# Explore Data

\tiny
```{r}
head(italy08) # second year of SHIW
```

# Reformat Data

\footnotesize
```{r}
id08 <- italy08$id
id10 <- italy10$id
id <- c(italy08$id, italy10$id) # combine the id
italy08 <- italy08[-c(1)] # remove the id
italy10 <- italy10[-c(1)] # remove the id 
italy <- rbind(italy08, italy10)
head(italy)
```



# Your turn

- Construct a blocking criterion for the SHIW data set. 
- Provide code to construct the blocks
- Are your blocks well balanced?
- What is the reduction ratio? 
- What is the pairwise recall and precision?
- Would you recommend your blocking criterion for an ER task? Why or why not. 

Hint: You might consider blocking on gender, regions (in Italy), or combinations of these. What do you find? 

# Your turn solution

Let's block on gender.

```{r}
# block by gender 
blockByGender <- italy$SEX
recordsPerBlock <- table(blockByGender)
head(recordsPerBlock)
```

# Your turn solution

The block sizes are similar. But note, they are still quite large. 

```{r}
# Checking block sizes 
plot(recordsPerBlock,
cex.axis=0.6, xlab="", ylab="")
```

# Your turn solution
```{r}
print(rr <- reduction.ratio(blockByGender))
```

We have reduced the overall space by rougly 50 percent. 

# Your turn solution

```{r}
precision(blockByGender, id)
recall(blockByGender, id)
```

This is not an optimal blocking criterion as ideally, we would want both the precision and recall to be close to 1. 

# Your turn solution

\tiny

Let's block on the twenty regions in Italy. 

```{r}
blockRule <- (italy$IREG) 
(recordsPerBlock <- table(blockRule))
plot(recordsPerBlock,
cex.axis=0.6, xlab="", ylab="")
print(rr <- reduction.ratio(blockRule))
precision(blockRule, id)
recall(blockRule, id)
```

# Your turn solution

Let's block on a combination of gender and region. 

\textcolor{red}{Trying to make this work using tidyverse as it seems more elegant.}


The histogram is not printing now for some reason. 

# Your turn solution

\tiny
```{r, message=FALSE}
italy %>%
  group_by(italy$IREG, italy$SEX) %>%
  summarise(count = n()) %>%
  group_by(count) %>%
  ggplot() +
  geom_histogram(aes(count))
```

This seems to provide a histogram of the blocks with the number of records in each block. Roughly we have about 1500 blocks, where the no block has more than five records. 

# Your turn solution

\tiny
```{r}
recordsPerBlock <- italy %>% 
group_by(IREG, SEX) %>% 
summarise(count = n(), .groups="drop")  %>% 
group_by(count) %>%
ggplot() +
geom_histogram(aes(count))
head(recordsPerBlock)
```

I can no longer provide a histogram of this any longer for some reason. 

# Your turn solution
\tiny
```{r}
grouping <- group_by(italy, italy$IREG, italy$SEX)
recordsPerBlock <- summarise(grouping, count=n())
blockIDs = paste0(italy$IREG, italy$SEX, sep="_")
table(recordsPerBlock$count)
print(rr <- reduction.ratio(recordsPerBlock$count))
precision(recordsPerBlock$count, blockIDs)
recall(recordsPerBlock$count, blockIDs)
```




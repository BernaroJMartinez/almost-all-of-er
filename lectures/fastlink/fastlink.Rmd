
---
title: "Module X: fastlink"
author: "Rebecca C. Steorts"
output: 
     beamer_presentation:
      includes: 
          in_header: custom2.tex
font-size: 8px
---

Reading
===

- Binette and Steorts (2020)
- Others ??


# Probabilistic Entity Resolution 

While Fellegi and Sunter (1969) have provided a framework for probabilistic entity resolution, there are few implmentations that scale to large size data sets. 

# fastlink

- Edmorando et al. (2020) developed fastlink
a scalable implementation of the FS method. 

- In addition, the authors incorporated
auxiliary information such as population name frequency and migration rates.

- The authors used parallelization and hashing to merge millions of records in
a near real-time on a laptop computer, and provided open-source software of
their proposed methodology. 

# Agreement Patterns

\begin{itemize}
\item Two data sets ($A$ and $B$) with variables in common
\item Agreement value in field $a$ for record pair $(i,j)$
\end{itemize}

$$\rho_a(i,j) \ = \ \left\{\begin{array}{l}   \color{blue}{\texttt{agree}} \\ \\
    								     \color{blue}{\texttt{disagree}} \end{array}
                               \right.$$
                               
                               


# Agreement Patterns

\begin{table}[]
\begin{tabular}{ccccccc}
    &  & First & Last &  Age & Street \\
  \hline
    & \multicolumn{3}{l}{Data set $\mathcal{A}$} \\
    &  1 &  \texttt{James}  	& \texttt{Smith}  	& \texttt{35} & \bf{{\texttt{Devereux St.}}} \\
    &  \multicolumn{3}{l}{Data set $\mathcal{B}$} \\
    &  7 &  \texttt{James} 	& \texttt{Smit} 		& \texttt{43} & \bf{{\texttt{Dvereux St.}}}  \\
	 \hdashline
    & & \color{blue} {\texttt{agree}} 	& \color{blue} {\texttt{agree}}  	& \color{blue} {\texttt{disagree}} 		&   \color{blue} {\bf{{\texttt{agree}}}} \\  \hline
\end{tabular}
\end{table}

\vspace*{4em}
\pause

\begin{center}
\textbf{Agreement pattern} $\gamma(i, j) = \{\gamma_1(i,j), \gamma_2(i,j), \ldots, \gamma_K(i,j) \}$ 
\end{center}  


# Agreement Patterns

- We observe agreement patterns $\gamma(i,j)$ 
- We do not observe the matching status 

$$C_{i,j} \ = \ \left\{\begin{array}{l}   \color{blue}{\texttt{non-match}} \\ \\
    								     \color{red}{\texttt{match}} \end{array}
                               \right.$$



# fastlink Model

\begin{center}
\begin{eqnarray*}
  C(i, j) & \iid & \text{Bernoulli}(\mu) \\ 
  \rho(i,j) \mid C(i, j) = \text{\color{blue}{non-match}} & \iid &  \mathcal{F}({ \color{blue}{\pi}_{\text{\color{blue}{NM}}} }) \\ 
  \rho(i,j) \mid C(i, j) = \text{\color{white}{non-}\color{red}{match}} & \iid &  \mathcal{F}( {\color{red}{\pi}_{\text{\color{red}{M}}} }) 
\end{eqnarray*} 
\end{center}

Where $\lambda$, ${\color{red}{\pi}_{\text{\color{red}{M}}}}$, ${\color{blue}{\pi}_{\text{\color{blue}{NM}}}}$  are estimated via the EM algorithm


# fastlink

- Available on CRAN
- We investigate it first on RLdata500

# fastlink in R

```{r}
library(fastLink)
library(RecordLinkage)
```

# RLdata10000

```{r}
# load RLdata10000
records <- read.table("data/RLdata10000.csv", sep=",", header=TRUE)
head(records, 4)
```

# RLdata10000

```{r}
# Number of unique records 
length(unique(records$ent_id))
```

#Linkage Fields

```{r}
# linkage fields 
linkageFields <- c("fname_c1", "lname_c1", "by", "bm", "bd")
```

# Exact Matching 

```{r}
# perform exact matching 
exact.match <- merge(records, records, by = linkageFields)

# number of self-matches
sum(exact.match$rec_id.x == exact.match$rec_id.y)

# number of non-self matches
sum(exact.match$rec_id.x != exact.match$rec_id.y)
```

# Who are they?

```{r}
head(exact.match[exact.match$rec_id.x 
                 != exact.match$rec_id.y,
                 c(linkageFields)], 4)

```


# Preparation 

```{r}
# linkage fields 
linkageFields <- c("fname_c1", "lname_c1", "by", "bm", "bd")

# string distance fields
stringDistFields <- c("fname_c1", "lname_c1")

# partial distance fields (fields where we allow
# for agree, disagree, and partially agree)
partialMatchFields <- c("fname_c1", "lname_c1")
```

# Run fastlink

```{r}

out <- fastLink(dfA = records,
                dfB = records,
                varnames = linkageFields,
                stringdist.match = stringDistFields, # JW by default
                partial.match = partialMatchFields,
                cut.a = 0.94, cut.p = 0.84, # JW cutoffs
                dedupe = FALSE # 1-to-1 match
)
```

# fastlink Objects

fastLink has the following objects as output: 

```{r}
names(out)
```

# Who is matched

The indices of each matched pair can be found in out$matches

```{r}
head(cbind(out$matches$inds.a, out$matches$inds.b), 6)
```

# Counting Patterns 

- Counts and FS weights for each patterns can be found in `out$EM$patterns.w`

- Legend: 2 = Agree; 1 = Partially Agree; 0 = Disagree

```{r}
tail(out$EM$patterns.w[, 1:7])
```

Matching Threshold
===

By default it is 0.85, but it can be easily changed:

```{r}
out <- fastLink(dfA = records, dfB = records, varnames = linkageFields,
stringdist.match = stringDistFields, partial.match = partialMatchFields,
cut.a = 0.94, cut.p = 0.84,
threshold.match = 0.90, # Matching threshold dedupe = FALSE
)
```

Exercises/TODO
===

- How would you calculate the precision and recall? 
- Apply this to a much large data set with blocking. (Make this another module).
